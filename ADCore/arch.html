<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Architecture &mdash; areaDetector Support</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme_overrides.css?v=254ed751" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="asynPortDriver" href="asynPortDriver.html" />
    <link rel="prev" title="Overview" href="overview.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            areaDetector
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../readme.html">Readme</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../user_guide.html">User Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Architecture</a></li>
<li class="toctree-l2"><a class="reference internal" href="asynPortDriver.html">asynPortDriver</a></li>
<li class="toctree-l2"><a class="reference internal" href="NDArray.html">NDArray</a></li>
<li class="toctree-l2"><a class="reference internal" href="../detector_drivers.html">Detector Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="plugins.html">areaDetector Plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="../additional_plugins.html">Additional plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="medm.html">MEDM screens</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ADViewers/ad_viewers.html">areaDetector Viewers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../acknowledgements.html">Acknowledgements and licenses</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../install_guide.html">Install Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release.html">Top-level Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ADCore_release.html">ADCore Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ADSupport_release.html">ADSupport Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../doxygen.html">Source Code Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../detectors.html">Supported Detectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../legacy_versions.html">Legacy Versions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">areaDetector</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../user_guide.html">areaDetector Users Guide</a></li>
      <li class="breadcrumb-item active">Architecture</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/ADCore/arch.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="architecture">
<h1>Architecture<a class="headerlink" href="#architecture" title="Link to this heading"></a></h1>
<p>The architecture of the areaDetector module is shown below.</p>
<img alt="../_images/areaDetectorArchitecture.png" src="../_images/areaDetectorArchitecture.png" />
<p>From the bottom to the top this architecture consists of the following:</p>
<ul class="simple">
<li><p>Layer 1. This is the layer that allows user written code to
communicate with the hardware. It is usually provided by the detector
vendor. It may consist of a library or DLL, of a socket protocol to a
driver, a Microsoft COM interface, etc.</p></li>
<li><p>Layer 2. This is the driver that is written for the areaDetector
application to control a particular detector. It is written in C++
and inherits from the ADDriver class. It uses the standard asyn
interfaces for control and status information. Each time it receives
a new data array it can pass it as an NDArray object to all Layer 3
clients that have registered for callbacks. This is the only code
that needs to be written to implement a new detector. Existing
drivers range from about 800 to 2600 lines of code.</p></li>
<li><p>Layer 3. Code running at this level is called a “plug-in”. This code
registers with a driver for a callback whenever there is a new data
array. The existing plugins implement file saving (NDPluginFile),
region-of-interest (ROI) calculations (NDPluginROI), statistics
calculations (NDPluginStats, NDPluginROIStat), image processing
(NDPluginProcess), geometric transformations (NDPluginTransform),
buffering and triggering (NDPluginCircularBuff), color mode
conversion (NDPluginColorConvert), graphics and text overlays
(NDPluginOverlay), exporting NDArray attributes as scalar and
waveform records (NDPluginAttribute), conversion of detector data to
standard EPICS array types for use by Channel Access clients
(NDPluginStdArrays), and conversion of NDArrays to EPICS pvAccess
(NDPluginPva). Plugins are written in C++ and inherit from
NDPluginDriver. Existing plugins range from about 300 to 3000 lines
of code.</p></li>
<li><p>Layer 4. This is standard asyn device support that comes with the
EPICS asyn module.</p></li>
<li><p>Layer 5. These are standard EPICS records, and EPICS database
(template) files that define records to communicate with drivers at
Layer 2 and plugins at Layer 3.</p></li>
<li><p>Layer 6. These are EPICS channel access clients, such as MEDM that
communicate with the records at Layer 5. areaDetector includes some
client applications that can display images using EPICS waveform and
other records communicating with the NDPluginStdArrays plugin at
Layer 3. Several of these clients are ImageJ plugins, and the other
is a freely runnable IDL application.</p></li>
</ul>
<p>The code in Layers 1-3 is essentially independent of EPICS. In principle
there are only 2 EPICS dependencies in this code.</p>
<ol class="arabic simple">
<li><p><a class="reference external" href="http://www.aps.anl.gov/epics/base/R3-14/12-docs/AppDevGuide/">libCom</a>.
libCom from EPICS base provides operating-system independent
functions for threads, mutexes, etc.</p></li>
<li><p><a class="reference external" href="https://github.com/epics-modules/asyn">asyn</a>. asyn is a
module that provides interthread messaging services, including
queueing and callbacks.</p></li>
</ol>
<p>In particular it is possible to eliminate layers 4-6 in the architecture
shown in Figure 1. This means that it is not necessary to run an EPICS
IOC or to use EPICS Channel Access when using the drivers and plugins at
Layers 2 and 3. This is demonstrated in the simDetectorNoIOC application
in ADSimDetector and in the unit tests in ADCore/ADApp/pluginTests.</p>
<p>The plugin architecture is very powerful, because new plugins can be
written for application-specific purposes. For example, a plugin could
be written to analyze images and do some application specific functions,
and such a plugin would then work with any detector driver. Plugins are
also powerful because they can be reconfigured at run-time. For example
the NDPluginStdArrays can switch from getting its array data from a
detector driver to an NDPluginROI plugin. That way it will switch from
displaying the entire detector to whatever sub-region the ROI driver has
selected. Any Channel Access clients connected to the NDPluginStdArrays
driver will automatically switch to displaying this subregion.
Similarly, the NDPluginFile plugin can be switched at run-time from
saving the entire image to saving a selected ROI, just by changing its
input source. Plugins can be used to form an image processing pipeline,
for example with a detector providing data to a color convert plugin,
which feeds an ROI plugin, which feeds a file saving plugin. Each plugin
can run in its own thread, and hence in its own cores on a modern
multi-core CPU.</p>
<p>The use of plugins is optional, and it is only plugins that require the
driver to make callbacks with image data. If there are no plugins being
used then EPICS can be used simply to control the detector, without
accessing the data itself. This is most useful when the vendor provides
an API has the ability to save the data to a file and an application to
display the images.</p>
<p>What follows is a detailed description of the software, working from the
bottom up. Most of the code is object oriented, and written in C++.</p>
<span class="target" id="implementation-details"></span></section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="overview.html" class="btn btn-neutral float-left" title="Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="asynPortDriver.html" class="btn btn-neutral float-right" title="asynPortDriver" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Mark Rivers.
      <span class="lastupdated">Last updated on 2024-February-09.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>